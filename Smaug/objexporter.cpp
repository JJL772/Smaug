#include "objexporter.h"
#include "worldeditor.h"

#include <sstream>

static inline void WriteVertex(glm::vec3 vec, std::stringstream& stream)
{
	stream << "v " << vec.x << " " << vec.y << " " << vec.z << "\n";
}



static const uint16_t g_quadTriIndexList[] = { 0, 1, 2, 2, 3, 0 };
static const uint16_t g_wallTriIndexList[] = { 0, 2, 3, 3, 1, 0 };

static inline void WriteFaceWall(int& vertNumber, std::stringstream& stream)
{
	// Tri 1
	stream << "f " << (g_wallTriIndexList[0] + vertNumber) << " " << (g_wallTriIndexList[1] + vertNumber) << " " << (g_wallTriIndexList[2] + vertNumber) << "\n";

	// Tri 2
	stream << "f " << (g_wallTriIndexList[3] + vertNumber) << " " << (g_wallTriIndexList[4] + vertNumber) << " " << (g_wallTriIndexList[5] + vertNumber) << "\n";

	vertNumber += 4;
}

static inline void WriteFaceFloorQuad(int& vertNumber, std::stringstream& stream)
{
	// Tri 1
	stream << "f " << (g_quadTriIndexList[0] + vertNumber) << " " << (g_quadTriIndexList[1] + vertNumber) << " " << (g_quadTriIndexList[2] + vertNumber) << "\n";

	// Tri 2
	stream << "f " << (g_quadTriIndexList[3] + vertNumber) << " " << (g_quadTriIndexList[4] + vertNumber) << " " << (g_quadTriIndexList[5] + vertNumber) << "\n";

	vertNumber += 4;
}

static inline void WriteFaceFloorTri(int& vertNumber, std::stringstream& stream)
{
	stream << "f " << (g_quadTriIndexList[0] + vertNumber) << " " << (g_quadTriIndexList[1] + vertNumber) << " " << (g_quadTriIndexList[2] + vertNumber) << "\n";

	vertNumber += 3;
}


char* COBJExporter::Export(CWorldEditor* world)
{
	std::stringstream stream;

	stream << "# Generated by Smaug - ";
#ifdef _DEBUG
	stream << "Debug";
#else
	stream << "Release";
#endif
	stream << " build compiled on " << __DATE__ << "\n";

	stream << "\n# Vertexes\n";
	for (int i = 0; i < world->m_nodes.size(); i++)
	{
		CNode* node = world->m_nodes[i];
		glm::vec3 origin = node->m_origin;
		stream << "# Node " << i << "\n";
		stream << "# Floor Verts\n";
		for (int j = 0; j < node->m_sideCount; j++)
			WriteVertex(node->m_vertexes[j].origin + origin, stream);

		stream << "# Wall Verts\n";
		for (int j = 0; j < node->m_sideCount; j++)
		{
			for (int k = 0; k < node->m_sides[j].walls.size(); k++)
			{
				nodeWall_t wall = node->m_sides[j].walls[k];
				WriteVertex(wall.bottomPoints[0] + origin, stream);
				WriteVertex(wall.bottomPoints[1] + origin, stream);
				WriteVertex(wall.topPoints[0] + origin, stream);
				WriteVertex(wall.topPoints[1] + origin, stream);
			}
		}
	}

	int vertNumber = 1;
	stream << "\n# Faces\n";
	for (int i = 0; i < world->m_nodes.size(); i++)
	{
		CNode* node = world->m_nodes[i];
		stream << "# Node " << i << "\n";
		stream << "# Floor Face\n";
		if (node->m_sideCount == 3)
			WriteFaceFloorTri(vertNumber, stream);
		else
			WriteFaceFloorQuad(vertNumber, stream);

		stream << "# Wall Faces\n";
		for (int j = 0; j < node->m_sideCount; j++)
		{
			for (int k = 0; k < node->m_sides[j].walls.size(); k++)
			{
				WriteFaceWall(vertNumber, stream);
			}
		}
	}


	// Output
	std::string str = stream.str();
	// I think this is probably dumb, but oh well
	char* strBuf = new char[str.size() + 1];
	memcpy(strBuf, str.c_str(), str.size());
	strBuf[str.size()] = 0;
	
	return strBuf;
}
